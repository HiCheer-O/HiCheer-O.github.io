---
title: 软件开发和设计专业名词
author: HiCheer
createTime: 2024/08/13 13:59:45
permalink: /article/nt1mp1fp/
---

### 常见名词
| 名称              | 描述                                                                                                                                  | 运用                                                                                                                                                   |
|-----------------|---------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
| 单一职责原则（SRP）     | 每个类应该只有一个引起它变化的原因，换句话说，每个类都应该只专注于完成一种功能。                                                                                        | 在设计类和模块时，确保每个类只有一个明确的职责。例如，一个类只负责数据访问，另一个类只负责业务逻辑。                                                     |
| 控制反转（IoC）     | 一种设计原则，用于将对象创建和依赖关系的管理交给外部容器，而不是在代码中硬编码。                                                                                               | 常用于依赖注入（DI）框架中，如Spring，通过IoC容器管理对象的生命周期和依赖关系，简化应用程序的配置和测试。                                                   |
| 依赖注入（DI）        | 将类的依赖通过构造器、方法或接口从外部传入，而不是在类内部直接创建依赖对象，降低耦合度。                                                                                     | 常用于Spring框架中，通过构造器注入、Setter注入、字段注入的方式实现依赖注入，增强模块的可测试性和灵活性。                                                     |
| 工厂模式            | 提供一个创建对象的接口，而不是显式地指定其具体类，客户端通过接口创建对象。                                                                                                 | 适用于需要创建多个相关或依赖对象的场景，尤其是在对象创建逻辑复杂或者需要与外部系统交互时。常见于Java中的`Factory`类或方法。                               |
| 观察者模式           | 定义对象间的一对多依赖关系，当一个对象状态发生变化时，所有依赖它的对象都会收到通知并自动更新。                                                                               | 在GUI应用程序中，当数据模型变化时自动更新视图层。也用于事件驱动系统，如事件总线或消息队列。                                                                |
| REST架构风格        | 一种基于资源的网络架构风格，使用标准的HTTP动词（GET、POST、PUT、DELETE）来操作资源，并通过URL访问这些资源。                                                                    | 常用于Web服务的设计，特别是在构建API时。RESTful API广泛用于现代Web应用程序中，特别是在微服务架构中。                                                         |
| 面向接口编程          | 代码依赖于接口而非具体实现类，降低系统耦合性，增强灵活性。                                                                                                                 | 在Java中，通过接口定义类的功能，并依赖接口进行编程。使得更换具体实现或扩展功能更加容易。                                                                  |
| 微服务架构           | 将应用程序分解为多个小型、自治的服务，每个服务都专注于完成一个特定的业务功能，并且可以独立部署和扩展。                                                                          | 适用于大型、复杂的系统，能够提高系统的可维护性和可扩展性。常见于电商平台、大型社交网络等分布式系统中。                                                        |
| 持续集成/持续交付（CI/CD） | 通过自动化构建、测试和部署流程，确保代码持续集成到主干并能快速部署到生产环境。                                                                                      | 在DevOps实践中广泛应用，用于提高软件交付的速度和质量。常见工具包括Jenkins、Travis CI、CircleCI等。                                                        |
| 代理模式            | 为另一个对象提供一个代理，以控制对这个对象的访问。                                                                                                                           | 用于在不改变目标对象的情况下，控制对目标对象的访问。常见于远程代理（如RMI）、虚拟代理（如懒加载）、保护代理（如权限控制）等场景。                                 |
| 策略模式            | 定义一系列算法或行为，并使得它们可以互换，客户端可以根据需要选择不同的算法或行为。                                                                                            | 适用于需要在运行时决定使用哪种算法的场景，如支付系统中选择不同的支付方式。Java中的`Comparator`接口常用于实现策略模式。                                         |
| 装饰者模式           | 动态地为对象添加新功能，而不改变其结构。                                                                                                                                       | 在需要扩展对象功能的场景中使用，如在不改变类结构的情况下为对象添加额外的责任或功能。常见于Java I/O流的设计，如`BufferedReader`装饰`Reader`。                   |
| 责任链模式           | 将多个对象连接成一条链，当请求到来时，沿着这条链传递，直到找到处理请求的对象。                                                                                                 | 常用于请求处理、权限校验等场景，特别是在存在多种处理方式且不希望将所有处理方式集中到一个对象中时。Java中的Servlet过滤器链就是责任链模式的一个例子。               |
| 单例模式            | 确保一个类只有一个实例，并提供一个全局访问点。                                                                                                                              | 在需要一个全局唯一对象时使用，如日志管理器、数据库连接池等。Java中常用的实现方式有饿汉式、懒汉式、双重校验锁等。                                                |
| 外观模式            | 为子系统中的一组接口提供一个一致的接口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。                                                                            | 在复杂系统中为简化用户接口而使用，减少客户端与子系统之间的交互复杂性。Java中常用于简化对复杂库的访问，如数据库访问的外观接口。                                   |
| 模板方法模式          | 定义一个算法的框架，并允许子类为一个或多个步骤提供具体实现。                                                                                                                 | 适用于具有相似操作流程的场景，如实现一个包含固定步骤的工作流。Java中的`AbstractList`类使用模板方法模式来定义列表的基本操作。                                     |
| 适配器模式           | 将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。                                                                               | 在需要将现有类与新接口集成时使用，如将旧系统的接口适配到新系统中。Java中的`java.util.Arrays#asList()`方法就是一个适配器，将数组适配成列表接口。                     |
| 迭代器模式           | 提供一种方法顺序访问一个集合对象中的各个元素，而不暴露其内部表示。                                                                                                          | 在需要遍历集合的场景中使用，如Java中的`Iterator`接口，提供了遍历集合的标准方法。                                                                                  |
| 代理模式            | 为另一个对象提供一个代理，以控制对这个对象的访问。                                                                                                                           | 用于在不改变目标对象的情况下，控制对目标对象的访问。常见于远程代理（如RMI）、虚拟代理（如懒加载）、保护代理（如权限控制）等场景。                                 |
| 命令模式            | 将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。                                                                                                           | 适用于需要将行为请求参数化或排队执行的场景，如GUI应用中的撤销操作、事务管理等。Java中的`java.lang.Runnable`就是一个典型的命令模式实现。                             |
| 状态模式            | 允许对象在内部状态改变时改变其行为。                                                                                                                                        | 用于对象需要根据状态变化表现不同行为的场景，如状态机、协议处理等。Java中的`javax.swing.JToggleButton`的开关状态就使用了状态模式。                                 |
| 备忘录模式           | 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复对象到先前的状态。                                                                          | 适用于需要保存和恢复对象状态的场景，如撤销操作、浏览器的历史记录功能。Java中的`java.util.Date`就是一种简化的备忘录实现。                                          |
| 访问者模式           | 为一个对象结构中的各元素提供多种访问方式，而不改变对象结构。                                                                                                                  | 适用于需要在不修改对象结构的情况下，为其添加新功能的场景，如对复杂对象结构执行操作或计算。Java中的`java.nio.file.FileVisitor`就是访问者模式的一个实现。             |
| 解释器模式           | 为语言创建解释器，定义一个语言的文法表示，并提供一个解释器来处理这些文法。                                                                                                    | 用于开发特定领域语言（DSL）或表达式计算引擎的场景，如SQL解析器、正则表达式引擎等。Java中的`java.util.regex.Pattern`就是解释器模式的一个实现。                       |
| 面向切面编程（AOP） | 一种编程范式，允许通过分离关注点来增强代码模块化，特别是在处理横切关注点（如日志记录、事务管理）时。Spring 中通过 AOP 来动态代理方法，在不修改原有代码的情况下添加额外的功能。 | 常用于日志记录、安全检查、事务管理、异常处理等场景，Spring AOP 通过注解或 XML 配置来定义切面和切入点。 |

### 常见锁
| **锁名称**                | **说明**                                                                                                                                             | **举例**                                                                                                       |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| **`synchronized` 锁**      | Java 内置锁，通过关键字 `synchronized` 来实现，作用于方法或代码块上，实现线程间的互斥访问。                                                         | ```java<br>public synchronized void method() {<br>   // 同步代码<br>}<br>```                                    |
| **重入锁 (ReentrantLock)** | Java `java.util.concurrent.locks` 包中的一种显式锁，支持重入、可中断和定时锁等高级功能。                                                            | ```java<br>ReentrantLock lock = new ReentrantLock();<br>lock.lock();<br>try {<br>   // 同步代码<br>} finally {<br>   lock.unlock();<br>}<br>``` |
| **读写锁 (ReadWriteLock)** | 允许多个读线程同时访问，但写线程独占访问的锁，适用于读多写少的场景。                                                                                | ```java<br>ReadWriteLock lock = new ReentrantReadWriteLock();<br>lock.readLock().lock();<br>try {<br>   // 读操作<br>} finally {<br>   lock.readLock().unlock();<br>}<br>``` |
| **自旋锁 (SpinLock)**      | 一种非阻塞锁，线程在尝试获取锁时不会立即进入阻塞状态，而是通过不断循环检查锁状态来获取锁。                                                          | ```java<br>while (!lock.compareAndSet(false, true)) {<br>   // 自旋等待<br>}<br>```                            |
| **悲观锁 (Pessimistic Lock)** | 假设在并发环境中会发生冲突，因此每次访问数据前都会加锁，保证每次只能有一个线程访问资源。                                                    | 数据库中的 `SELECT ... FOR UPDATE` 语句便是悲观锁的一种实现。                                                   |
| **乐观锁 (Optimistic Lock)** | 假设在并发环境中不会发生冲突，操作时不加锁，但在提交时会检查冲突并决定是否重试。                                                                | 通过版本号机制（如 CAS 操作）来实现，例如在 `AtomicInteger` 中使用 `compareAndSet` 方法。                         |
| **死锁 (Deadlock)**        | 指两个或多个线程互相等待对方持有的锁而陷入无限等待的状态。                                                                                        | 线程 A 持有锁 1 并等待锁 2，而线程 B 持有锁 2 并等待锁 1，从而产生死锁。                                         |
| **公平锁 (Fair Lock)**     | 保证线程获取锁的顺序按照线程请求锁的顺序进行，避免“饥饿”现象的发生。                                                                              | `ReentrantLock` 可以通过构造函数设置为公平锁：`new ReentrantLock(true)`。                                       |
| **非公平锁 (Non-Fair Lock)** | 不保证线程获取锁的顺序，可能导致某些线程长时间得不到锁，造成“饥饿”现象，但性能较高。                                                          | `ReentrantLock` 默认是非公平锁：`new ReentrantLock()`。                                                         |
| **可重入锁 (Reentrant Lock)** | 允许同一个线程多次获取同一把锁，而不会发生死锁。                                                                                            | `synchronized` 和 `ReentrantLock` 都是可重入锁。                                                                 |
| **不可重入锁 (Non-Reentrant Lock)** | 一旦线程持有锁后，再次获取该锁会发生死锁，通常不建议使用。                                                                                      | 自定义锁实现时，可能会遇到不可重入锁的场景。                                                                     |
| **行锁 (Row Lock)**        | 行锁是数据库层面的一种锁机制，用于锁定表中的特定行，以便防止其他事务对该行进行并发修改。行锁的粒度较小，适用于需要高并发操作的场景。              | 在 MySQL 中，InnoDB 引擎的行级锁在执行 `SELECT ... FOR UPDATE` 或者 `UPDATE` 语句时，会锁住相应的行。           |
| **表锁 (Table Lock)**      | 表锁是数据库层面的一种锁机制，用于锁定整个表，以防止其他事务对该表进行并发操作。表锁的粒度较大，适用于读多写少的场景。                        | 在 MySQL 中，使用 `LOCK TABLES ... WRITE` 语句可以对整个表加锁。                                               |
| **分段锁 (Segmented Lock)**| 分段锁是一种基于分段的锁机制，通过将数据分成多个段，每个段有一个独立的锁，从而减少锁争用，提高并发性。分段锁通常用于实现高性能的缓存或哈希表。 | 在 Java 中，`ConcurrentHashMap` 采用了分段锁机制，每个段独立加锁，减少了并发访问时的锁竞争。                    |
